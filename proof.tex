\documentclass{article}
%[twocolumn]

% ~~~~~~~~~~~~~~~~~~~~~~~ Preamble ~~~~~~~~~~~~~~~~~~~~~~~

\usepackage{bpextra}
\usepackage[margin=1.5in]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{subcaption}
\usepackage{float}
\usepackage{enumitem}
\usepackage{titlesec}


%\titleformat{\section}
%  {\normalfont\scshape}{\thesection}{1em}{}

% no paragraph indent
\setlength{\parindent}{0pt}
\setlength{\columnsep}{2em}

% delta-equals (unused)
\def\deltaeq{\mathrel{\ensurestackMath{\stackon[1pt]{=}{\scriptstyle\Delta}}}}
\def\defeq{::=}


% indented definitions, lemmas etc
\makeatletter
\newtheoremstyle{indented}
    {5pt}% space before
    {5pt}% space after
    {\addtolength{\@totalleftmargin}{0em}
     \addtolength{\linewidth}{-0em}
     \parshape 1 0em \linewidth}% body font
    {-0em}% indent
    {\bfseries}% header font
    {.}% punctuation
    {.5em}% after theorem header
    {}% header specification (empty for default)
\makeatother

% theorems with global counter
\theoremstyle{indented}
\newtheorem{sec-ctr}{???}[section]
\newtheorem{theorem}[sec-ctr]{Theorem}
\newtheorem{definition}[sec-ctr]{Definition}
\newtheorem*{definition*}{Definition}
\newtheorem{lemma}[sec-ctr]{Lemma}
\newtheorem*{lemma*}{Lemma}
\newtheorem{example}[sec-ctr]{Example}
\newtheorem*{example*}{Example}
\newtheorem*{examples}{Examples}
\newtheorem{corollary}[sec-ctr]{Corollary}
\newtheorem*{corollary*}{Corollary}
\newtheorem{remark}[sec-ctr]{Remark}
\newtheorem*{remark*}{Remark}
\newtheorem*{remarks}{Remarks}

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\title{Natural Proof Search for Classical Logic}
\author{Adam Lassiter\\Department of Computer Science\\University of Bath \and Willem Heijltjes\\Department of Computer Science\\University of Bath}
\date{\today}

\begin{document}
    \maketitle
    \begin{abstract}
        \textbf{We investigate a natural algorithm for proof search within classical logic.}
    \end{abstract}

    \section{Additive Classical Logic}

        \begin{definition}{Formulae\\}
            A \textit{formula} within additive classical logic is constructed as follows:
            \begin{align*}
                \quad A, B, C                &\defeq \bot \,|\, \top \,|\, a \,|\, \neg\, a \,|\, A \vee B \,|\, A \wedge B \\
                \quad \Gamma, \Delta, \Sigma &\defeq A_1 \ldots A_n
            \end{align*}
            where $\vee, \wedge$ are classical disjunction and conjunction respectively and $\Gamma, \Delta, \Sigma$ are contexts..
        \end{definition}

        \begin{example*}
        \end{example*}


        \begin{definition}{Sequent Proofs\\}
            Within \textit{additive classical logic}, a \textit{sequent proof} is constructed from the following rules:\\
            \begin{minipage}[H]{\linewidth}
                \centering
                \begin{minipage}[H]{.3\linewidth}
                    \begin{prooftree}
                        \AxiomC{~}
                        \RightLabel{$\top$}
                        \UnaryInfC{$\vdash \top$}
                    \end{prooftree}
                    \begin{prooftree}
                        \AxiomC{~}
                        \RightLabel{$ax$}
                        \UnaryInfC{$\vdash a, \neg\, a$}
                    \end{prooftree}
                \end{minipage}
                \begin{minipage}[H]{.3\linewidth}
                    \begin{prooftree}
                        \AxiomC{$\vdash \Gamma, A$}
                        \RightLabel{$\vee$R}
                        \UnaryInfC{$\vdash \Gamma, A \vee B$}
                    \end{prooftree}
                    \begin{prooftree}
                        \AxiomC{$\vdash \Gamma, A$}
                        \AxiomC{$\vdash \Gamma, B$}
                        \RightLabel{$\wedge$R}
                        \BinaryInfC{$\vdash \Gamma, A \wedge B$}
                    \end{prooftree}
                \end{minipage}
                \begin{minipage}[H]{.3\linewidth}
                    \begin{prooftree}
                        \AxiomC{$\vdash \Gamma$}
                        \RightLabel{$w$}
                        \UnaryInfC{$\vdash \Gamma, A$}
                    \end{prooftree}
                    \begin{prooftree}
                        \AxiomC{$\vdash \Gamma, A, A$}
                        \RightLabel{$c$}
                        \UnaryInfC{$\vdash \Gamma, A$}
                    \end{prooftree}
                \end{minipage}
            \end{minipage}~\\
            where $A, B, C$ are formulae and $\Gamma, \Delta, \Sigma$ are sequents.
            A sequent proof provides, without context, a proof of its conclusion and each line of the proof represents a tautology.
        \end{definition}

        \begin{example*}
        \end{example*}


        \begin{remark}
            Within the context of weakening and contraction, \textit{additive} and \textit{multiplicative} rules are inter-derivable.
        \end{remark}


        \begin{definition}{Derivations\\}
            A \textit{derivation} is a proof tree where the leaves need not necessarily be proven.
            Given \textit{tops} $\Gamma_1 \ldots \Gamma_n$ for the sequent proof $\vdash \Delta$, the tree essentially provides a proof of $\Gamma_1 \ldots \Gamma_n \implies \Delta$.\\

            A derivation is written as:
            \begin{prooftree}
                \AxiomC{$\vdash \Gamma_1$}
                \AxiomC{$\ldots$}
                \AxiomC{$\vdash \Gamma_n$}
                \RightLabel{\textit{[label]}}
                \doubleLine\TrinaryInfC{$\vdash \Delta$}
            \end{prooftree}
            where the \textit{label} describes which rules may be used within the derivation.
        \end{definition}

        \begin{corollary}{Derivation Equivalence\\}
            A sequent proof is a derivation where all leaves of the tree are $\top$ or $a, \neg a$.
            Equivalence of derivations may be weakly defined up to equivalence of leaves and conclusion.
        \end{corollary}

        \begin{example*}
        \end{example*}


        \begin{definition}{Additive Stratification\\}
            A proof tree is said to be \textit{additively stratified} if $\vdash A$ is structured as follows:
            \begin{prooftree}
                \AxiomC{}
                \RightLabel{$ax, w$}
                \doubleLine\UnaryInfC{$\vdash \Gamma_1$}
                \AxiomC{\ldots}
                \AxiomC{}
                \RightLabel{$ax, w$}
                \doubleLine\UnaryInfC{$\vdash \Gamma_n$}
                \RightLabel{$\wedge, \vee$}
                \doubleLine\TrinaryInfC{$\vdash A \ldots A$}
                \RightLabel{$c$}
                \doubleLine\UnaryInfC{$\vdash A$}
            \end{prooftree}
            That is, the deductions made in an additively stratified proof are strictly ordered by:
            \setlist{nolistsep}
            \begin{itemize}[noitemsep]
                \item Top/Atomic
                \item Weakening
                \item Conjunction/Disjunction
                \item Contraction
            \end{itemize}
        \end{definition}
        
        \begin{example*}
        \end{example*}


        \begin{theorem}{Stratification Equivalence\\}
            Given $\vdash A$, there exists an additively stratified proof of $A$.
        \end{theorem}
        \begin{proof}
            By examining each neighbouring pair of deductions.
            \begin{enumerate}
                \item For each instance of a weakening below another deduction, there exists an equivalent subproof that is additively stratified.
                \item Similarly, for each instance of a contraction above another deduction, there exists an equivalent subproof that is additively stratified.
                \item Finally, given any proof tree, the process of continued substitutions both halts and produces an additively stratified proof tree.
            \end{enumerate}
        \end{proof}



    \section{Petri Nets}
        
        \begin{definition}{Petri Nets\\}
            A petri net is \ldots
        \end{definition}

        \begin{example*}
        \end{example*}

        
        \begin{definition}{Coalescence\\}
            The coalescence algorithm is \ldots
        \end{definition}


        \begin{theorem}{Coalescence Proof Search\\}
            The coalescence algorithm is a proof search \ldots
        \end{theorem}

        \begin{proof}
            By relation of:
            \begin{itemize}
                \item $c$ $\iff$ dimensionality
                \item $ax$ $\iff$ 2-D token initialisation
                \item $w$ $\iff$ n-D extension of tokens
                \item $\wedge$R, $\vee$R $\equiv$ petri net firing
            \end{itemize}
        \end{proof}
        
\end{document}
